
## 虚拟内存
虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。

CPU 通过一个虚拟地址（virtual address,VA）来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址。
将虚拟地址转换成物理地址的任务叫做地址翻译（address translation）。

要明白一个重要的概念：
  对于CPU来说，它的目标存储器是物理内存，使用高速缓存做物理内存的缓存
  同样，对于虚拟内存来说，它的目标存储器是磁盘空间，使用物理内存做磁盘的缓存

所以，从缓存原理的角度来理解，在任何时刻，虚拟页的集合都分为3个不相交的子集：
  未分配的页，即没有任何数据和这些虚拟页关联，不占用任何磁盘空间
  缓存的页，即已经分配了的虚拟页，并且已经缓存在具体的物理页中
  未缓存的页，即已经为磁盘文件分配了虚拟页，但是还没有缓存到具体的物理页中

虚拟内存系统和高速缓存系统一样，需要判断一个虚拟页面是否缓存在DRAM(主存)中，如果命中，就直接找到对应的物理页。
如果不命中，操作系统需要知道这个虚拟页对应磁盘的哪个位置，然后根据相应的替换策略从DRAM中选择一个牺牲的物理页，
把虚拟页从磁盘中加载到DRAM物理主存中

虚拟内存的这种缓存管理机制是通过操作系统内核，MMU(内存管理单元)中的地址翻译硬件和
每个进程存放在主存中的页表(page table)数据结构
来实现的。

### 页表


### 缺页异常

当CPU想要读取包含在某个虚拟页的内容时，如果该页已经缓存在主存中，也就是页命中。perfect,很完美。
但是如果该页没有缓存在主存中，则我们称之为缺页(page fault) 。 如上图所示，CPU 引用了 VP3 中的内容， 
VP3 并未缓存在主存中。系统从内存中读取 PTE3,得知 VP3 未被缓存，这会触发了一个缺页异常。
缺页异常会调用kernel的缺页异常处理程序，该程序会选择一个牺牲页。
如下图所示，牺牲页选择了存放在 PP3 中的 VP4。此时如果 VP4 的内容被修改了，kernel会将它复制回磁盘。
接下来，kernel从磁盘赋值 VP3 到内存中的 PP3并更新 PTE3。随后返回用户进程。当异常处理程序返回时，
它会重启执行导致缺页的指令，当重新执行这条指令时，因为 VP3 已经在主存中了，此时就是页命中了。


      我们刚才说，缺页错误是一种异常，但是实际上，在计算机系统中，被0除，读写文件，还有上篇文章中我们所说的中断(interrupt)，
      甚至包括我们代码中写的try catch，都是一种异常。 比如被0除是intel 的CPU规定的的第0号故障(fault)类型的异常。
      而读写文件，分别是linux规定的第0号和第1号陷阱(trap)类型的异常。多任务的上下文切换，进程的创建回收等等与系统中
      这种异常流的处理密切相关。当然，这是另外一个话题了。我们在这里不做累述。

### 虚拟内存作为内存管理和内存保护的工具
理所当然的，每个进程都有一个独立的页表和一个独立的虚拟地址空间

回到文章开头的问题，比如每个C程序都要调用的 stdio这个库，不可能为每个进程都添加一份库，
内存中只有一份stdio库的内容，供每个使用该库的进程共享。

大家再看一下"图:12 进程地址空间",就会发现在地址空间当中，"共享库的内存映射区域"对于每个进程起始地址都是相同的。
再想想进程之间共享内存的通信方式, 所以说虚拟内存简化了共享机制。

大家知道，C语言中存在指针，可以直接进行内存操作。因为有了虚拟内存，所以我们的指针操作也不会访问到其他进程的区域，
但是哪怕是对于自己的地址空间，很多内存区域也应该是禁止访问的，这不仅包括kernel的区域，也包括自己的只读代码段。
那么虚拟内存就提供了这样的一种内存保护工具。

地址翻译机制可以使用一种自然的方式来提供内存的访问控制。
PTE 上添加一些额外的控制位来添加权限。每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE 。页表条目(Page Table Entry,PTE)



